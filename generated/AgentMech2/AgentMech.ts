// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class Deliver extends ethereum.Event {
  get params(): Deliver__Params {
    return new Deliver__Params(this);
  }
}

export class Deliver__Params {
  _event: Deliver;

  constructor(event: Deliver) {
    this._event = event;
  }

  get sender(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get requestId(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get data(): Bytes {
    return this._event.parameters[2].value.toBytes();
  }
}

export class PriceUpdated extends ethereum.Event {
  get params(): PriceUpdated__Params {
    return new PriceUpdated__Params(this);
  }
}

export class PriceUpdated__Params {
  _event: PriceUpdated;

  constructor(event: PriceUpdated) {
    this._event = event;
  }

  get price(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }
}

export class Request extends ethereum.Event {
  get params(): Request__Params {
    return new Request__Params(this);
  }
}

export class Request__Params {
  _event: Request;

  constructor(event: Request) {
    this._event = event;
  }

  get sender(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get requestId(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get data(): Bytes {
    return this._event.parameters[2].value.toBytes();
  }
}

export class AgentMech__validateUserOpInputUserOpStruct extends ethereum.Tuple {
  get sender(): Address {
    return this[0].toAddress();
  }

  get nonce(): BigInt {
    return this[1].toBigInt();
  }

  get initCode(): Bytes {
    return this[2].toBytes();
  }

  get callData(): Bytes {
    return this[3].toBytes();
  }

  get callGasLimit(): BigInt {
    return this[4].toBigInt();
  }

  get verificationGasLimit(): BigInt {
    return this[5].toBigInt();
  }

  get preVerificationGas(): BigInt {
    return this[6].toBigInt();
  }

  get maxFeePerGas(): BigInt {
    return this[7].toBigInt();
  }

  get maxPriorityFeePerGas(): BigInt {
    return this[8].toBigInt();
  }

  get paymasterAndData(): Bytes {
    return this[9].toBytes();
  }

  get signature(): Bytes {
    return this[10].toBytes();
  }
}

export class AgentMech extends ethereum.SmartContract {
  static bind(address: Address): AgentMech {
    return new AgentMech("AgentMech", address);
  }

  DOMAIN_SEPARATOR_TYPE_HASH(): Bytes {
    let result = super.call(
      "DOMAIN_SEPARATOR_TYPE_HASH",
      "DOMAIN_SEPARATOR_TYPE_HASH():(bytes32)",
      []
    );

    return result[0].toBytes();
  }

  try_DOMAIN_SEPARATOR_TYPE_HASH(): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "DOMAIN_SEPARATOR_TYPE_HASH",
      "DOMAIN_SEPARATOR_TYPE_HASH():(bytes32)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  VERSION(): string {
    let result = super.call("VERSION", "VERSION():(string)", []);

    return result[0].toString();
  }

  try_VERSION(): ethereum.CallResult<string> {
    let result = super.tryCall("VERSION", "VERSION():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  chainId(): BigInt {
    let result = super.call("chainId", "chainId():(uint256)", []);

    return result[0].toBigInt();
  }

  try_chainId(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("chainId", "chainId():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  domainSeparator(): Bytes {
    let result = super.call(
      "domainSeparator",
      "domainSeparator():(bytes32)",
      []
    );

    return result[0].toBytes();
  }

  try_domainSeparator(): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "domainSeparator",
      "domainSeparator():(bytes32)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  entryPoint(): Address {
    let result = super.call("entryPoint", "entryPoint():(address)", []);

    return result[0].toAddress();
  }

  try_entryPoint(): ethereum.CallResult<Address> {
    let result = super.tryCall("entryPoint", "entryPoint():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  exec(
    to: Address,
    value: BigInt,
    data: Bytes,
    operation: i32,
    txGas: BigInt
  ): Bytes {
    let result = super.call(
      "exec",
      "exec(address,uint256,bytes,uint8,uint256):(bytes)",
      [
        ethereum.Value.fromAddress(to),
        ethereum.Value.fromUnsignedBigInt(value),
        ethereum.Value.fromBytes(data),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(operation)),
        ethereum.Value.fromUnsignedBigInt(txGas)
      ]
    );

    return result[0].toBytes();
  }

  try_exec(
    to: Address,
    value: BigInt,
    data: Bytes,
    operation: i32,
    txGas: BigInt
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "exec",
      "exec(address,uint256,bytes,uint8,uint256):(bytes)",
      [
        ethereum.Value.fromAddress(to),
        ethereum.Value.fromUnsignedBigInt(value),
        ethereum.Value.fromBytes(data),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(operation)),
        ethereum.Value.fromUnsignedBigInt(txGas)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  getDomainSeparator(): Bytes {
    let result = super.call(
      "getDomainSeparator",
      "getDomainSeparator():(bytes32)",
      []
    );

    return result[0].toBytes();
  }

  try_getDomainSeparator(): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "getDomainSeparator",
      "getDomainSeparator():(bytes32)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  getRequestId(account: Address, data: Bytes): BigInt {
    let result = super.call(
      "getRequestId",
      "getRequestId(address,bytes):(uint256)",
      [ethereum.Value.fromAddress(account), ethereum.Value.fromBytes(data)]
    );

    return result[0].toBigInt();
  }

  try_getRequestId(account: Address, data: Bytes): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getRequestId",
      "getRequestId(address,bytes):(uint256)",
      [ethereum.Value.fromAddress(account), ethereum.Value.fromBytes(data)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getRequestIdWithNonce(account: Address, data: Bytes, nonce: BigInt): BigInt {
    let result = super.call(
      "getRequestIdWithNonce",
      "getRequestIdWithNonce(address,bytes,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(account),
        ethereum.Value.fromBytes(data),
        ethereum.Value.fromUnsignedBigInt(nonce)
      ]
    );

    return result[0].toBigInt();
  }

  try_getRequestIdWithNonce(
    account: Address,
    data: Bytes,
    nonce: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getRequestIdWithNonce",
      "getRequestIdWithNonce(address,bytes,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(account),
        ethereum.Value.fromBytes(data),
        ethereum.Value.fromUnsignedBigInt(nonce)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getRequestStatus(requestId: BigInt): i32 {
    let result = super.call(
      "getRequestStatus",
      "getRequestStatus(uint256):(uint8)",
      [ethereum.Value.fromUnsignedBigInt(requestId)]
    );

    return result[0].toI32();
  }

  try_getRequestStatus(requestId: BigInt): ethereum.CallResult<i32> {
    let result = super.tryCall(
      "getRequestStatus",
      "getRequestStatus(uint256):(uint8)",
      [ethereum.Value.fromUnsignedBigInt(requestId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  getRequestsCount(account: Address): BigInt {
    let result = super.call(
      "getRequestsCount",
      "getRequestsCount(address):(uint256)",
      [ethereum.Value.fromAddress(account)]
    );

    return result[0].toBigInt();
  }

  try_getRequestsCount(account: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getRequestsCount",
      "getRequestsCount(address):(uint256)",
      [ethereum.Value.fromAddress(account)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getUndeliveredRequestIds(size: BigInt, offset: BigInt): Array<BigInt> {
    let result = super.call(
      "getUndeliveredRequestIds",
      "getUndeliveredRequestIds(uint256,uint256):(uint256[])",
      [
        ethereum.Value.fromUnsignedBigInt(size),
        ethereum.Value.fromUnsignedBigInt(offset)
      ]
    );

    return result[0].toBigIntArray();
  }

  try_getUndeliveredRequestIds(
    size: BigInt,
    offset: BigInt
  ): ethereum.CallResult<Array<BigInt>> {
    let result = super.tryCall(
      "getUndeliveredRequestIds",
      "getUndeliveredRequestIds(uint256,uint256):(uint256[])",
      [
        ethereum.Value.fromUnsignedBigInt(size),
        ethereum.Value.fromUnsignedBigInt(offset)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigIntArray());
  }

  isOperator(signer: Address): boolean {
    let result = super.call("isOperator", "isOperator(address):(bool)", [
      ethereum.Value.fromAddress(signer)
    ]);

    return result[0].toBoolean();
  }

  try_isOperator(signer: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("isOperator", "isOperator(address):(bool)", [
      ethereum.Value.fromAddress(signer)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isValidSignature(hash: Bytes, signature: Bytes): Bytes {
    let result = super.call(
      "isValidSignature",
      "isValidSignature(bytes32,bytes):(bytes4)",
      [ethereum.Value.fromFixedBytes(hash), ethereum.Value.fromBytes(signature)]
    );

    return result[0].toBytes();
  }

  try_isValidSignature(
    hash: Bytes,
    signature: Bytes
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "isValidSignature",
      "isValidSignature(bytes32,bytes):(bytes4)",
      [ethereum.Value.fromFixedBytes(hash), ethereum.Value.fromBytes(signature)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  mapNonces(param0: Address): BigInt {
    let result = super.call("mapNonces", "mapNonces(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBigInt();
  }

  try_mapNonces(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("mapNonces", "mapNonces(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  mapRequestAddresses(param0: BigInt): Address {
    let result = super.call(
      "mapRequestAddresses",
      "mapRequestAddresses(uint256):(address)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );

    return result[0].toAddress();
  }

  try_mapRequestAddresses(param0: BigInt): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "mapRequestAddresses",
      "mapRequestAddresses(uint256):(address)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  mapRequestIds(param0: BigInt, param1: BigInt): BigInt {
    let result = super.call(
      "mapRequestIds",
      "mapRequestIds(uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );

    return result[0].toBigInt();
  }

  try_mapRequestIds(
    param0: BigInt,
    param1: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "mapRequestIds",
      "mapRequestIds(uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  mapRequestsCounts(param0: Address): BigInt {
    let result = super.call(
      "mapRequestsCounts",
      "mapRequestsCounts(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toBigInt();
  }

  try_mapRequestsCounts(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "mapRequestsCounts",
      "mapRequestsCounts(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  nonce(): BigInt {
    let result = super.call("nonce", "nonce():(uint256)", []);

    return result[0].toBigInt();
  }

  try_nonce(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("nonce", "nonce():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  numTotalRequests(): BigInt {
    let result = super.call(
      "numTotalRequests",
      "numTotalRequests():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_numTotalRequests(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "numTotalRequests",
      "numTotalRequests():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  numUndeliveredRequests(): BigInt {
    let result = super.call(
      "numUndeliveredRequests",
      "numUndeliveredRequests():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_numUndeliveredRequests(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "numUndeliveredRequests",
      "numUndeliveredRequests():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  onERC1155BatchReceived(
    param0: Address,
    param1: Address,
    param2: Array<BigInt>,
    param3: Array<BigInt>,
    param4: Bytes
  ): Bytes {
    let result = super.call(
      "onERC1155BatchReceived",
      "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigIntArray(param2),
        ethereum.Value.fromUnsignedBigIntArray(param3),
        ethereum.Value.fromBytes(param4)
      ]
    );

    return result[0].toBytes();
  }

  try_onERC1155BatchReceived(
    param0: Address,
    param1: Address,
    param2: Array<BigInt>,
    param3: Array<BigInt>,
    param4: Bytes
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "onERC1155BatchReceived",
      "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigIntArray(param2),
        ethereum.Value.fromUnsignedBigIntArray(param3),
        ethereum.Value.fromBytes(param4)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  onERC1155Received(
    param0: Address,
    param1: Address,
    param2: BigInt,
    param3: BigInt,
    param4: Bytes
  ): Bytes {
    let result = super.call(
      "onERC1155Received",
      "onERC1155Received(address,address,uint256,uint256,bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigInt(param2),
        ethereum.Value.fromUnsignedBigInt(param3),
        ethereum.Value.fromBytes(param4)
      ]
    );

    return result[0].toBytes();
  }

  try_onERC1155Received(
    param0: Address,
    param1: Address,
    param2: BigInt,
    param3: BigInt,
    param4: Bytes
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "onERC1155Received",
      "onERC1155Received(address,address,uint256,uint256,bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigInt(param2),
        ethereum.Value.fromUnsignedBigInt(param3),
        ethereum.Value.fromBytes(param4)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  onERC721Received(
    param0: Address,
    param1: Address,
    param2: BigInt,
    param3: Bytes
  ): Bytes {
    let result = super.call(
      "onERC721Received",
      "onERC721Received(address,address,uint256,bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigInt(param2),
        ethereum.Value.fromBytes(param3)
      ]
    );

    return result[0].toBytes();
  }

  try_onERC721Received(
    param0: Address,
    param1: Address,
    param2: BigInt,
    param3: Bytes
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "onERC721Received",
      "onERC721Received(address,address,uint256,bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigInt(param2),
        ethereum.Value.fromBytes(param3)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  price(): BigInt {
    let result = super.call("price", "price():(uint256)", []);

    return result[0].toBigInt();
  }

  try_price(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("price", "price():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  token(): Address {
    let result = super.call("token", "token():(address)", []);

    return result[0].toAddress();
  }

  try_token(): ethereum.CallResult<Address> {
    let result = super.tryCall("token", "token():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  tokenId(): BigInt {
    let result = super.call("tokenId", "tokenId():(uint256)", []);

    return result[0].toBigInt();
  }

  try_tokenId(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("tokenId", "tokenId():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  validateUserOp(
    userOp: AgentMech__validateUserOpInputUserOpStruct,
    userOpHash: Bytes,
    missingAccountFunds: BigInt
  ): BigInt {
    let result = super.call(
      "validateUserOp",
      "validateUserOp((address,uint256,bytes,bytes,uint256,uint256,uint256,uint256,uint256,bytes,bytes),bytes32,uint256):(uint256)",
      [
        ethereum.Value.fromTuple(userOp),
        ethereum.Value.fromFixedBytes(userOpHash),
        ethereum.Value.fromUnsignedBigInt(missingAccountFunds)
      ]
    );

    return result[0].toBigInt();
  }

  try_validateUserOp(
    userOp: AgentMech__validateUserOpInputUserOpStruct,
    userOpHash: Bytes,
    missingAccountFunds: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "validateUserOp",
      "validateUserOp((address,uint256,bytes,bytes,uint256,uint256,uint256,uint256,uint256,bytes,bytes),bytes32,uint256):(uint256)",
      [
        ethereum.Value.fromTuple(userOp),
        ethereum.Value.fromFixedBytes(userOpHash),
        ethereum.Value.fromUnsignedBigInt(missingAccountFunds)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get _token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _tokenId(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get _price(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class DeliverCall extends ethereum.Call {
  get inputs(): DeliverCall__Inputs {
    return new DeliverCall__Inputs(this);
  }

  get outputs(): DeliverCall__Outputs {
    return new DeliverCall__Outputs(this);
  }
}

export class DeliverCall__Inputs {
  _call: DeliverCall;

  constructor(call: DeliverCall) {
    this._call = call;
  }

  get requestId(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get data(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }
}

export class DeliverCall__Outputs {
  _call: DeliverCall;

  constructor(call: DeliverCall) {
    this._call = call;
  }
}

export class ExecCall extends ethereum.Call {
  get inputs(): ExecCall__Inputs {
    return new ExecCall__Inputs(this);
  }

  get outputs(): ExecCall__Outputs {
    return new ExecCall__Outputs(this);
  }
}

export class ExecCall__Inputs {
  _call: ExecCall;

  constructor(call: ExecCall) {
    this._call = call;
  }

  get to(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get value(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get data(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }

  get operation(): i32 {
    return this._call.inputValues[3].value.toI32();
  }

  get txGas(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }
}

export class ExecCall__Outputs {
  _call: ExecCall;

  constructor(call: ExecCall) {
    this._call = call;
  }

  get returnData(): Bytes {
    return this._call.outputValues[0].value.toBytes();
  }
}

export class RequestCall extends ethereum.Call {
  get inputs(): RequestCall__Inputs {
    return new RequestCall__Inputs(this);
  }

  get outputs(): RequestCall__Outputs {
    return new RequestCall__Outputs(this);
  }
}

export class RequestCall__Inputs {
  _call: RequestCall;

  constructor(call: RequestCall) {
    this._call = call;
  }

  get data(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }
}

export class RequestCall__Outputs {
  _call: RequestCall;

  constructor(call: RequestCall) {
    this._call = call;
  }

  get requestId(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class SetPriceCall extends ethereum.Call {
  get inputs(): SetPriceCall__Inputs {
    return new SetPriceCall__Inputs(this);
  }

  get outputs(): SetPriceCall__Outputs {
    return new SetPriceCall__Outputs(this);
  }
}

export class SetPriceCall__Inputs {
  _call: SetPriceCall;

  constructor(call: SetPriceCall) {
    this._call = call;
  }

  get newPrice(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class SetPriceCall__Outputs {
  _call: SetPriceCall;

  constructor(call: SetPriceCall) {
    this._call = call;
  }
}

export class SetUpCall extends ethereum.Call {
  get inputs(): SetUpCall__Inputs {
    return new SetUpCall__Inputs(this);
  }

  get outputs(): SetUpCall__Outputs {
    return new SetUpCall__Outputs(this);
  }
}

export class SetUpCall__Inputs {
  _call: SetUpCall;

  constructor(call: SetUpCall) {
    this._call = call;
  }

  get initParams(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }
}

export class SetUpCall__Outputs {
  _call: SetUpCall;

  constructor(call: SetUpCall) {
    this._call = call;
  }
}

export class ValidateUserOpCall extends ethereum.Call {
  get inputs(): ValidateUserOpCall__Inputs {
    return new ValidateUserOpCall__Inputs(this);
  }

  get outputs(): ValidateUserOpCall__Outputs {
    return new ValidateUserOpCall__Outputs(this);
  }
}

export class ValidateUserOpCall__Inputs {
  _call: ValidateUserOpCall;

  constructor(call: ValidateUserOpCall) {
    this._call = call;
  }

  get userOp(): ValidateUserOpCallUserOpStruct {
    return changetype<ValidateUserOpCallUserOpStruct>(
      this._call.inputValues[0].value.toTuple()
    );
  }

  get userOpHash(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get missingAccountFunds(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class ValidateUserOpCall__Outputs {
  _call: ValidateUserOpCall;

  constructor(call: ValidateUserOpCall) {
    this._call = call;
  }

  get validationData(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class ValidateUserOpCallUserOpStruct extends ethereum.Tuple {
  get sender(): Address {
    return this[0].toAddress();
  }

  get nonce(): BigInt {
    return this[1].toBigInt();
  }

  get initCode(): Bytes {
    return this[2].toBytes();
  }

  get callData(): Bytes {
    return this[3].toBytes();
  }

  get callGasLimit(): BigInt {
    return this[4].toBigInt();
  }

  get verificationGasLimit(): BigInt {
    return this[5].toBigInt();
  }

  get preVerificationGas(): BigInt {
    return this[6].toBigInt();
  }

  get maxFeePerGas(): BigInt {
    return this[7].toBigInt();
  }

  get maxPriorityFeePerGas(): BigInt {
    return this[8].toBigInt();
  }

  get paymasterAndData(): Bytes {
    return this[9].toBytes();
  }

  get signature(): Bytes {
    return this[10].toBytes();
  }
}
